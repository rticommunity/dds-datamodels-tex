// copyright 2017, 2018 BAE Systems, Thales Group, Object Management Group Inc
// copyright 2022, 2023 BAE Systems, Real-Time Innovations, SimVentions, Object Management Group Inc

#ifndef ORGOMGTEXDATAPAYLOADENTITYPAYLOADDEFVAR
#define ORGOMGTEXDATAPAYLOADENTITYPAYLOADDEFVAR
#include "CategorizationData.idl"
#include "Util.idl"

module org
{

  module omg
  {

    module tex
    {

      module DataPayload
      {

        @doc("EntityPayload is the package of the classes needed to define the data exchanged \
            with a TACSIT system for entities.")
        module EntityPayload
        {

          @doc("Coordinates in a Cartesian reference frame as described by a coordinate \
            specification object (from [OARIS]).")
          struct CartesianPosition
          {
            @doc("X position of the point. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance x;
            @doc("Y position of the point. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance y;
            @doc("Altitude of the point. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance z;
          };

          @doc("The Meta Data of an Entity.")
          struct EntityMetaData
          {
            @doc("The publisher of the entity.")
            string publisher;
            @doc("An external identifier for the entity. This identifier is not bound to be unique \
                among entities.")
            string identifier;
            @doc("Type of security Policy (e.g.: NATO).")
            string securityPolicy;
            @doc("Security classification in the preceding policy (e.g. UNCLASSIFED, NATO COSMIC \
                SECRET).")
            string securityClassification;
            @doc("Description of the security classification (e.g. \"Releasable for Internet \
                transmission\").")
            string securityCategory;
          };

          @doc("Enumeration of specialisations options for union class EntityPayload.")
          @appendable
          enum EntityPayloadKind
          {
            @doc("AggregateEntity option for EntityPayload")
            AGGREGATE_ENTITY_KIND,
            @doc("CompositeEntity option for EntityPayload")
            COMPOSITE_ENTITY_KIND,
            @doc("ShapedEntity option for EntityPayload")
            SHAPED_ENTITY_KIND
          };

          @doc("This class allows for extended data for an entity. An extended data is defined by \
            a schema/key/value triple, the schema being a group of keys (sort of namespace). \
            Extended Data are typically used to holds business-specific data that may be \
            drawn/written around a symbol. \
            Annex A standardizes a first set of extended data keys.")
          struct ExtendedData
          {
            @doc("Key of the extended data to be taken in the schema.")
            string key;
            @doc("Value matching the key.")
            string value;
            org::omg::tex::DataPayload::Util::ExtensionSchema schema;
          };

          @doc("Triangular representation of a full covariance matrix (which is by definition \
            symmetric).")
          struct FullCovarianceMatrix
          {
            @doc("The variance of the x coordinate value")
            org::omg::tex::DataPayload::Util::Variance xxVariance;
            @doc("The covariance of the x coordinate with the y coordinate.")
            org::omg::tex::DataPayload::Util::Variance xyVariance;
            @doc("The covariance of the x coordinate with the z coordinate.")
            org::omg::tex::DataPayload::Util::Variance xzVariance;
            @doc("The covariance of the x coordinate with the x velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance xvxVariance;
            @doc("The covariance of the x coordinate with the y velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance xvyVariance;
            @doc("The covariance of the x coordinate with the z velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance xvzVariance;
            @doc("The variance of the y coordinate value")
            org::omg::tex::DataPayload::Util::Variance yyVariance;
            @doc("The covariance of the y coordinate with the z coordinate.")
            org::omg::tex::DataPayload::Util::Variance yzVariance;
            @doc("The covariance of the y coordinate with the x velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance yvxVariance;
            @doc("The covariance of the y coordinate with the y velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance yvyVariance;
            @doc("The covariance of the y coordinate with the z velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance yvzVariance;
            @doc("The variance of the z coordinate value")
            org::omg::tex::DataPayload::Util::Variance zzVariance;
            @doc("The covariance of the z coordinate with the x velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance zvxVariance;
            @doc("The covariance of the z coordinate with the y velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance zvyVariance;
            @doc("The covariance of the z coordinate with the z velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance zvzVariance;
            @doc("The variance of the x component of velocity")
            org::omg::tex::DataPayload::Util::Variance vxvxVariance;
            @doc("The covariance of the x velocity coordinate with the y velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance vxvyVariance;
            @doc("The covariance of the x velocity coordinate with the z velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance vxvzVariance;
            @doc("The variance of the y component of velocity")
            org::omg::tex::DataPayload::Util::Variance vyvyVariance;
            @doc("The covariance of the y velocity coordinate with the z velocity coordinate.")
            org::omg::tex::DataPayload::Util::Variance vyvzVariance;
            @doc("The variance of the z component of velocity")
            org::omg::tex::DataPayload::Util::Variance vzvzVariance;
          };

          @doc("Coordinates in a Geodetic reference frame as described by a coordinate \
            specification object (from [OARIS]). \
            The datum (WGS84...) is set by the group.")
          struct GeodeticPosition
          {
            @doc("Latitude of the point. \
                The Angle unit as well as the projection are set by the Group.")
            org::omg::tex::DataPayload::Util::Angle latitude;
            @doc("Longitude of the point. \
                The Angle unit as well as the projection are set by the Group.")
            org::omg::tex::DataPayload::Util::Angle longitude;
            @doc("Altitude of the point. \
                The Distance unit as well as the projection are set by the Group.")
            org::omg::tex::DataPayload::Util::Distance altitude;
          };

          @doc("Coordinates in a polar reference frame as a described by a coordinate \
            specification object (from [OARIS]).")
          struct PolarPosition
          {
            @doc("Azimuth of the point. \
                The Angle unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Angle azimuth;
            @doc("Elevation of the point. \
                The Angle unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Angle elevation;
            @doc("Distance of the point from the center. \
                The Distance unit as well as the projection are set by the Group.")
            org::omg::tex::DataPayload::Util::Distance range;
          };

          @doc("Enumeration of specialisations options for union class PositionCoordinate.")
          @appendable
          enum PositionCoordinateKind
          {
            @doc("CartesianPosition option for PositionCoordinate")
            CARTESIAN_POSITION_KIND,
            @doc("GeodeticPosition option for PositionCoordinate")
            GEODETIC_POSITION_KIND,
            @doc("PolarPosition option for PositionCoordinate")
            POLAR_POSITION_KIND
          };

          @doc("Enumeration of specialisations options for union class ShapedEntity.")
          @appendable
          enum ShapedEntityKind
          {
            @doc("AmbiguousBearings option for ShapedEntity")
            AMBIGUOUS_BEARINGS_KIND,
            @doc("Annulus option for ShapedEntity")
            ANNULUS_KIND,
            @doc("Arc option for ShapedEntity")
            ARC_KIND,
            @doc("Arcband option for ShapedEntity")
            ARCBAND_KIND,
            @doc("Arrow option for ShapedEntity")
            ARROW_KIND,
            @doc("Bearing option for ShapedEntity")
            BEARING_KIND,
            @doc("Circle option for ShapedEntity")
            CIRCLE_KIND,
            @doc("Corridor option for ShapedEntity")
            CORRIDOR_KIND,
            @doc("Ellipse option for ShapedEntity")
            ELLIPSE_KIND,
            @doc("FreeShapedEntity option for ShapedEntity")
            FREE_SHAPED_ENTITY_KIND,
            @doc("Multipoint option for ShapedEntity")
            MULTIPOINT_KIND,
            @doc("Orbit option for ShapedEntity")
            ORBIT_KIND,
            @doc("Point option for ShapedEntity")
            POINT_KIND,
            @doc("Polygon option for ShapedEntity")
            POLYGON_KIND,
            @doc("Polyline option for ShapedEntity")
            POLYLINE_KIND,
            @doc("Rectangle option for ShapedEntity")
            RECTANGLE_KIND,
            @doc("StickyNote option for ShapedEntity")
            STICKY_NOTE_KIND,
            @doc("Text option for ShapedEntity")
            TEXT_KIND
          };

          @doc("An EntityRef is a reference to an EntityPayload. Its actual representation \
            depends upon the PSM used.")
          typedef org::omg::tex::DataPayload::Util::URI EntityRef;

          @doc("Interpolation of the line positions between two points is performed using one of \
            the following methodologies: \
            - Rhumb Line - constant heading; \
            - Great Circle - shortest path; \
            - ScreenProjection - Screen.")
          enum InterpolationMethodology
          {
            @doc("Interpolation along a straight line on a Mercator projection chart.")
            RhumbLine,
            @doc("Interpolation along the surface of the sphere.")
            GreatCircle,
            @doc("Interpolation along a straight line on the screen.")
            ScreenProjection
          };

          @doc("Enumeration of the lifecycle status for an EntityPayload.")
          enum ReportType
          {
            @doc("State that the EntityPayload has been created.")
            NEW,
            @doc("State that the EntityPayload has been modified.")
            UPDATE,
            @doc("State that the EntityPayload has been lost.")
            LOST,
            @doc("State that the EntityPayload has been resumed (after lost).")
            RESUMED,
            @doc("State that an EntityPayload has been dropped from the system.")
            DROPPED
          };

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<org::omg::tex::DataPayload::Util::URI> AggregateEntityGroupedEntities_id;

          @doc("An entity representing a loose grouping of other groups. Recursion is allowed, \
            but is an error to include an entity into the group which that entity, itself, \
            defines.")
          struct AggregateEntity
          {
            // The entites that are members of the aggregate entity
            AggregateEntityGroupedEntities_id groupedEntities_id;
          };

          @doc("A string type \
            Typdef for bounded string type for attribute svgDefinition of class FreeShapedEntity.")
          typedef string FreeShapedEntitySvgDefinition;

          @doc("A string type \
            Typdef for bounded string type for attribute text of class StickyNote.")
          typedef string StickyNoteText;

          @doc("A string type \
            Typdef for bounded string type for attribute font of class StickyNote.")
          typedef string StickyNoteFont;

          @doc("A string type \
            Typdef for bounded string type for attribute textColor of class StickyNote.")
          typedef string StickyNoteTextColor;

          @doc("A string type \
            Typdef for bounded string type for attribute backgroundColor of class StickyNote.")
          typedef string StickyNoteBackgroundColor;

          @doc("A string type \
            Typdef for bounded string type for attribute borderStyle of class StickyNote.")
          typedef string StickyNoteBorderStyle;

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<ExtendedData> ShapedEntityExtendedData;

          @doc("Union of the specialisations for class PositionCoordinate. \
            A georeferenced point. \
            The type of coordinate (WGS84/Cartesian/Polar), the type of orientation as well \
            as the type of origin are set by the group.")
          @appendable
          union PositionCoordinate switch (PositionCoordinateKind)
          {
            @doc("CartesianPosition option for PositionCoordinate")
            case CARTESIAN_POSITION_KIND : CartesianPosition cartesianPosition;
            @doc("GeodeticPosition option for PositionCoordinate")
            case GEODETIC_POSITION_KIND : GeodeticPosition geodeticPosition;
            @doc("PolarPosition option for PositionCoordinate")
            case POLAR_POSITION_KIND : PolarPosition polarPosition;
          };

          @doc("An entity represented as an area between two concentric circles and two radials \
            of those circles. The annulus is defined by the two radii of the circles.")
          struct Annulus
          {
            @doc("The radius of the smaller circle. This number should be positive \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance minRadius;
            @doc("The radius of the larger circle. This number should be positive \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance maxRadius;
            PositionCoordinate center;
          };

          @doc("An entity represented as a segment of the outline of an ellipse. It is defined by \
            the ellipse it is part of and the start and end angle of the arc on that ellipse. \
            The arc is defined in a clockwise direction from the startangle to the endangle.")
          struct Arc
          {
            @doc("The North-South (before rotation) semi-axis of the ellipse. This number should be \
                positive. The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance NSSemiAxis;
            @doc("The East-West (before rotation) semi-axis of the ellipse. This number should be \
                positive. The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance EWSemiAxis;
            @doc("The start angle of the arc along an ellipse prior to rotation. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle startAngle;
            @doc("The end angle of the arc along an ellipse prior to rotation. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle endAngle;
            @doc("Rotation in the counter-clockwise direction. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle rotation;
            PositionCoordinate center;
          };

          @doc("An entity represented as an area between two concentric circles and two radials \
            of those circles. The arcband is defined by the two radii of the circles and the \
            two angles of the radials moving from startangle to endangle in a clockwise \
            direction.")
          struct Arcband
          {
            @doc("The radius of the smaller circle. This number should be positive \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance minRadius;
            @doc("The radius of the smaller circle. This number should be positive \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance maxRadius;
            @doc("The start angle of the arc along an ellipse prior to rotation. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle startAngle;
            @doc("The end angle of the arc along an ellipse prior to rotation. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle endAngle;
            PositionCoordinate center;
          };

          @doc("An entity represented as a circle.")
          struct Circle
          {
            @doc("Radius of the center of the circle. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance radius;
            PositionCoordinate center;
          };

          @doc("An entity represented as an ellipse.")
          struct Ellipse
          {
            @doc("The North-South (before rotation) semi-axis of the ellipse. This number should be \
                positive. The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance NSSemiAxis;
            @doc("The East-West (before rotation) semi-axis of the ellipse. This number should be \
                positive. The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance EWSemiAxis;
            @doc("Rotation in the counter-clockwise direction. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle rotation;
            PositionCoordinate center;
          };

          @doc("An entity represented as a rectangle.")
          struct Rectangle
          {
            @doc("The dimension from center point to edge (half distance) of the rectangle along \
                its North-South length. This number should be positive. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance NSHalfDistance;
            @doc("The dimension from center point to edge (half distance) of the rectangle along \
                its East-West length. This number should be positive. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance EWHalfDistance;
            @doc("Rotation in the counter-clockwise direction. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle rotation;
            PositionCoordinate center;
          };

          @doc("An entity represented as a text. \
            The 'point' attribute gives the left-lower starting position for left-to-right \
            top-to-bottom languages, the right-lower starting position for right-to-left \
            top-to-bottom languages, the left-upper starting position for top-to-bottom \
            left-to-right languages and the right-upper starting position for top-to-bottom \
             right-to-left languages. \
            This attribute is implementation dependent for the other languages.")
          struct Text
          {
            @doc("The text to be displayed.")
            string content;
            @doc("Rotation in the counter-clockwise direction. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle rotation;
            PositionCoordinate point;
          };

          @doc("Struct of base attributes defined for class EntityPayload.")
          struct EntityPayloadBase
          {
            @doc("A Uniform Resource Identifier (URI) that uniquely identifies the object.")
            @key org::omg::tex::DataPayload::Util::URI id;
            @doc("Short description.")
            string label;
            @doc("Additional human-readable text.")
            string info;
            @doc("A URL to human readable content providing more information about the object.")
            org::omg::tex::DataPayload::Util::URL href;
            @doc("A show/hide period.")
            org::omg::tex::DataPayload::Util::Period timeSpan;
            @doc("The date of validity of the information held by the entity.")
            org::omg::tex::DataPayload::Util::DateTime timeStamp;
            @optional EntityMetaData metaData;
            @doc("Lifecycle status of the EntityPayload. \
                Default is UPDATE.")
            @optional ReportType reportType;
          };

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<PositionCoordinate> ArrowPoints;

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<PositionCoordinate> CorridorPoints;

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<PositionCoordinate> MultipointPoints;

          @doc("An entity that is know to exist somewhere along a line of one of two angles of \
              azimuth from an origin (typically the location of a passive towed array sonar), \
              but there is no information regarding its range (distance from the origin). On a \
              TACSIT each ambiguous bearing should be represented as a line from the origin to \
              the edge of the display.")
          struct AmbiguousBearings
          {
            @doc("one of the ambiguous angles of azimuth")
            org::omg::tex::DataPayload::Util::Angle bearingA;
            @doc("the other ambiguous angle of azimuth")
            org::omg::tex::DataPayload::Util::Angle bearingB;
            @optional PositionCoordinate origin;
          };

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<PositionCoordinate> PolygonPoints;

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<PositionCoordinate> PolylinePoints;

          @doc("An entity represented as an arrow defined by an ordered set of points and a body \
            width. The arrowhead is at the last point.")
          struct Arrow
          {
            @doc("Width of the arrow body. Width must be greater than zero. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance width;
            ArrowPoints points;
          };

          @doc("An entity that is know to exist somewhere along a line of azimuth from an origin \
            (typically the location of a passive sensor), but there is no information \
            regarding its range (distance from the origin). On a TACSIT a bearing should be \
            represented as a line from the origin to the edge of the display.")
          struct Bearing
          {
            @doc("The angle of azimuth for the bearing")
            org::omg::tex::DataPayload::Util::Angle azimuth;
            @optional PositionCoordinate origin;
          };

          @doc("An entity represented as a corridor.")
          struct Corridor
          {
            @doc("Width of the Corridor. Width must be greater than zero. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance width;
            CorridorPoints points;
          };

          @doc("A multipoint is a list of points without the semantics of a polyline (each point \
            must be linked with a line) or a polygon (each point must be linked with a line \
            and the figure is closed). The semantics is given by the associated \
            CategorizationData. As examples, 2525 and APP6 series make a clear difference \
            between multipoint and line. \
            The rotation says that once the figure is drawn according to the \
            CategorizationData, it must be rotated.")
          struct Multipoint
          {
            @doc("Rotation in the counter-clockwise direction. \
                The unit is set by the group.")
            org::omg::tex::DataPayload::Util::Angle rotation;
            MultipointPoints points;
          };

          @doc("An entity represented as a polygon.")
          struct Polygon
          {
            PolygonPoints points;
          };

          @doc("An entity represented as a polyline.")
          struct Polyline
          {
            PolylinePoints points;
          };

          @doc("An entity represented as a point.")
          struct Point
          {
            PositionCoordinate center;
            @optional FullCovarianceMatrix covariance;
          };

          @doc("An entity represented in a client specific format through the SVG (Scalable \
            Vector Graphics) standard. \
            It has an optional origin. If it contains an origin then the SVG coordinates are \
            interpreted as Cartesian relative to that origin. If there is no origin then the \
            coordinates are interpreted with respect to a related entity (from an Entity \
            Relation) as Cartesian. If there is no related entity then the coordinates are \
            interpreted as absolute latitudes (y) and longitudes (x). \
            This class supports the display of geometry for entities for which the TACSIT has \
            no pre-defined symbology standard.")
          struct FreeShapedEntity
          {
            @doc("An SVG xml file defining the appearance of the free shaped entity.")
            FreeShapedEntitySvgDefinition svgDefinition;
            @optional PositionCoordinate origin;
          };

          @doc("An entity represented as an orbit path. \
            The intended result the shape formed by linking together two half circles with \
            two lines (a.k.a. an athletics track by the sportsmen among us). The first circle \
            is centered on point one and the second circle is centered on point two. Both of \
            them has the same radius given by the width attribute.")
          struct Orbit
          {
            @doc("Width of the orbit. Width must be greater than zero. \
                The Distance unit is set by the Group.")
            org::omg::tex::DataPayload::Util::Distance width;
            PositionCoordinate pointOne;
            PositionCoordinate pointTwo;
          };

          @doc("Struct of base attributes defined for class ShapedEntity.")
          struct ShapedEntityBase
          {
            @doc("Direction of the movement wrt altitude, if any. \
                The unit is set by the group.")
            @optional org::omg::tex::DataPayload::Util::Angle climbAngle;
            @doc("Direction of the movement, if any. \
                The unit is set by the group.")
            @optional org::omg::tex::DataPayload::Util::Angle directionOfMovement;
            @doc("Whether the shape is defined relative to the heading (direction of movement) of \
                the entity")
            boolean isHeadingRelative;
            @doc("Speed of movement. \
                The unit is set by the group.")
            @optional org::omg::tex::DataPayload::Util::Speed speed;
            @doc("Data needed to draw the symbol of the entity.")
            org::omg::tex::DataPayload::CategorizationData::CategorizationData categorization;
            @doc("Extensible data.")
            ShapedEntityExtendedData extendedData;
            @doc("Data needed to draw the symbol of the entity in 3D.")
            @optional org::omg::tex::DataPayload::CategorizationData::CategorizationIn3D CategorizationIn3D;
            @doc("Interpolation method for the shape.")
            @optional InterpolationMethodology legType;
          };

          @doc("A note with a handle. \
            Also know as a Post-It note (\"Post-It\" is a registered 3M trademark).")
          struct StickyNote
          {
            @doc("Text of the note")
            StickyNoteText text;
            @doc("Font family (aka typeface) used to write the text within the note.")
            StickyNoteFont font;
            @doc("Color of the text in the note. \
                The way this color is mapped to RGB or other values is implementation dependent.")
            StickyNoteTextColor textColor;
            @doc("Color of the note itself. \
                The way this color is mapped to RGB or other values is implementation dependent.")
            StickyNoteBackgroundColor backgroundColor;
            @doc("Style of the border of the note. \
                The way this style is mapped is implementation dependent.")
            StickyNoteBorderStyle borderStyle;
            @doc("Horizontal gap between the center of the text block and the end of the handle. In \
                pixels.")
            short offsetX;
            @doc("Vertical gap between the center of the text block and the end of the handle. In \
                pixels.")
            short offsetY;
            PositionCoordinate point;
          };

          @doc("Union of the variant attributes for the specialisations for class ShapedEntity. \
            The base for most items.")
          @appendable
          union ShapedEntityVariants switch (ShapedEntityKind)
          {
            @doc("AmbiguousBearings option for ShapedEntity")
            case AMBIGUOUS_BEARINGS_KIND : AmbiguousBearings ambiguousBearings;
            @doc("Annulus option for ShapedEntity")
            case ANNULUS_KIND : Annulus annulus;
            @doc("Arc option for ShapedEntity")
            case ARC_KIND : Arc arc;
            @doc("Arcband option for ShapedEntity")
            case ARCBAND_KIND : Arcband arcband;
            @doc("Arrow option for ShapedEntity")
            case ARROW_KIND : Arrow arrow;
            @doc("Bearing option for ShapedEntity")
            case BEARING_KIND : Bearing bearing;
            @doc("Circle option for ShapedEntity")
            case CIRCLE_KIND : Circle circle;
            @doc("Corridor option for ShapedEntity")
            case CORRIDOR_KIND : Corridor corridor;
            @doc("Ellipse option for ShapedEntity")
            case ELLIPSE_KIND : Ellipse ellipse;
            @doc("FreeShapedEntity option for ShapedEntity")
            case FREE_SHAPED_ENTITY_KIND : FreeShapedEntity freeShapedEntity;
            @doc("Multipoint option for ShapedEntity")
            case MULTIPOINT_KIND : Multipoint multipoint;
            @doc("Orbit option for ShapedEntity")
            case ORBIT_KIND : Orbit orbit;
            @doc("Point option for ShapedEntity")
            case POINT_KIND : Point point;
            @doc("Polygon option for ShapedEntity")
            case POLYGON_KIND : Polygon polygon;
            @doc("Polyline option for ShapedEntity")
            case POLYLINE_KIND : Polyline polyline;
            @doc("Rectangle option for ShapedEntity")
            case RECTANGLE_KIND : Rectangle rectangle;
            @doc("StickyNote option for ShapedEntity")
            case STICKY_NOTE_KIND : StickyNote stickyNote;
            @doc("Text option for ShapedEntity")
            case TEXT_KIND : Text text;
          };

          struct ShapedEntity
          {
            @doc("base option for ShapedEntity")
            ShapedEntityBase shapedEntityBase;
            @doc("variant options for ShapedEntity")
            ShapedEntityVariants shapedEntityVariants;
          };

          @doc("A sequence type, to represent multiple values.")
          typedef sequence<ShapedEntity> CompositeEntityComposedEntities;

          @doc("Content unbreakable composition made of basic shapes (no recursion).")
          struct CompositeEntity
          {
            @doc("entities in the composition")
            CompositeEntityComposedEntities composedEntities;
          };

          @doc("Union of the variant attributes for the specialisations for class EntityPayload. \
            The definition of an entity as it appears in the exchanges with TACSIT. \
            The 'reportType' attributes gives the lifecycle status of this payload showing \
            that it is a creation, a modification and so forth. \
            Note: the 'id' attribute is used by the TACSIT system to identify the \
            EntityPayload while the 'identifier' attribute of the EntityMetatData is used by \
            the system which requested the creation of this EntityPayload to identify it \
            internally. 'identifier' is so a way to let this using system to find back its \
            data when getting back an entity from TACSIT.")
          @appendable
          union EntityPayloadVariants switch (EntityPayloadKind)
          {
            @doc("AggregateEntity option for EntityPayload")
            case AGGREGATE_ENTITY_KIND : AggregateEntity aggregateEntity;
            @doc("CompositeEntity option for EntityPayload")
            case COMPOSITE_ENTITY_KIND : CompositeEntity compositeEntity;
            @doc("ShapedEntity option for EntityPayload")
            case SHAPED_ENTITY_KIND : ShapedEntity shapedEntity;
          };

          struct EntityPayload
          {
            @doc("base option for EntityPayload")
            @key EntityPayloadBase entityPayloadBase;
            @doc("variant options for EntityPayload")
            EntityPayloadVariants entityPayloadVariants;
          };

        };
      };
    };
  };
};
#endif
